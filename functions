#!/usr/bin/env bash

mkd () { mkdir -p "$@" && cd "$_" || exit; }

git-hack () {
	local remote parent branch_name

	branch_name="$1"
	[ -z "${branch_name}" ] && return 1

	# shellcheck disable=SC2046
	# shellcheck disable=SC2015
	remote=$([ $(git remote | wc -l) = 1 ] && git remote || git-remote-choose)
	[ -z "${remote}" ] && return 1

	gum spin --spinner points --title "Fetching" -- git fetch --prune --tags

	echo 'Select parent branch'
	parent=$(git-branch-choose)
	[ -z "${parent}" ] && return 1

	git add -A
	git stash
	git checkout "${parent}"
	git rebase "${remote}"/"${parent}"
	git branch "${branch_name}" "${parent}"
	git checkout "${branch_name}"
	git stash pop
}

git-sync () {
	local remote parent branch_name

	branch_name=$(git rev-parse --abbrev-ref HEAD)
	[ -z "${branch_name}" ] && return 1

	# shellcheck disable=SC2046
	# shellcheck disable=SC2015
	remote=$([ $(git remote | wc -l) = 1 ] && git remote || git-remote-choose)
	[ -z "${remote}" ] && return 1

	gum spin --spinner points --title "Fetching..." -- git fetch --prune --tags

	echo 'Select parent branch'
	parent=$(git-branch-choose)
	[ -z "${parent}" ] && return 1

	git add -A
	git stash
	git checkout "${parent}"
	git pull
	git checkout offline-handling
	git merge --no-edit "${remote}"/offline-handling
	git merge --no-edit "${parent}"
	git push
	git stash pop
}

git-prune-branches () {
	local branches
	gum spin --spinner points --title "Fetching..." -- git fetch --prune --tags
	echo 'Branches'
	git branch -vv
	echo ''
	branches=$(git branch -vv | grep gone | awk '{print $1}')
	if [[ "${branches}" ]]; then
		echo 'Dangling branches found'
		echo "${branches}" | gum choose --no-limit | xargs git branch -D
	else
		echo 'No dangling branches found'
	fi
}

batgrep () {
	rg --line-number --no-heading --color=always --smart-case "$@" |
		fzf -d ':' -n 2.. --ansi --no-sort \
			--preview-window="up,60%,border-bottom,+{2}+3/3" \
			--preview 'bat --style=numbers --color=always --highlight-line {2} {1}';
}

# Kitty requires the remote server to have kitty-terminfo installed for the user
# The ssh alias should automatically handle this however there are some scenarios where it can't
# Other options:
#  - running the following ssh-kitty-terminfo function
#  - install using the package manager on the remote (ie. `apt install kitty-terminfo` or `dnf install kitty-terminfo`)
#  - override the TERM to something semi-compatible (ie `export TERM=xterm-256color` or `export TERM=xterm`
ssh-kitty-terminfo () { infocmp -a xterm-kitty | ssh "$@" tic -x -o \~/.terminfo /dev/stdin; }

# Required for broot
br() {
    local cmd cmd_file code
    cmd_file=$(mktemp)
    if broot --outcmd "$cmd_file" "$@"; then
        cmd=$(<"$cmd_file")
        rm -f "$cmd_file"
        eval "$cmd"
    else
        code=$?
        rm -f "$cmd_file"
        return "$code"
    fi
}

# base64 encode / decode
encode-base64 () { echo "$1" | base64; }
decode-base64 () { echo "$1" | base64 --decode; }

# Create a data URL from a file
dataurl () {
	local mimeType;
	mimeType=$(file -b --mime-type "$1");
	if [[ $mimeType == text/* ]]; then
		mimeType="${mimeType};charset=utf-8";
	fi
	echo "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')";
}

# IP addresses
localip () { ifconfig en0 | grep inet | awk '$1=="inet" {print $2}'; }
publicip-v4 () { dig -4 TXT +short o-o.myaddr.l.google.com @ns1.google.com; }
publicip-v6 () { dig -6 TXT +short o-o.myaddr.l.google.com @ns1.google.com; }
publicip () {
	echo "Public IPv4: $( publicip-v4 )";
	echo "Public IPv6: $( publicip-v6 )";
}

qr () {
	local input="$*"
	[ -z "$input" ] && local input="@/dev/stdin"
	curl -d "$input" https://qrcode.show
}

qr-svg () {
	local input="$*"
	[ -z "$input" ] && local input="@/dev/stdin"
	curl -d "${input}" https://qrcode.show -H "Accept: image/svg+xml"
}

convert-to-gif () {
	INPUT="$1"
	FRAMERATE=$(gum input --prompt "Frame rate: " --placeholder "Frame Rate" --value "10")
	WIDTH=$(gum input --prompt "Width: " --placeholder "Width" --value "1200")
	MAXCOLORS=$(gum input --prompt "Max Colors: " --placeholder "Max Colors" --value "256")

	BASENAME=$(basename "$INPUT")
	BASENAME="${BASENAME%%.*}"

	gum spin --spinner points --title "Converting to GIF" -- \
		ffmpeg -i "$INPUT" -vf "fps=$FRAMERATE,scale=$WIDTH:-1:flags=lanczos,split[s0][s1];[s0]palettegen=max_colors=${MAXCOLORS}[p];[s1][p]paletteuse" "$BASENAME.gif"
}

aws-info () {
	aws iam list-account-aliases | jq -r '."AccountAliases" | join(",")'
	aws sts get-caller-identity | jq .
}
